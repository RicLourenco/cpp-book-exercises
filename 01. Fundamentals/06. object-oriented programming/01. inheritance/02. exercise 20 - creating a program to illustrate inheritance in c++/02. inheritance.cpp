/* When inheriting from a class, the base class gets embedded into the derived class.
This means that all the data of the base class also becomes part of the derived
class in its memory representation

When writing the constructor of the derived class, the compiler will implicitly
call the default constructor of the base class before any initialization takes
place. If the base class does not have a default constructor but has aconstructor
that accepts parameters, then the derived class constructor can explicitly call it
in the initialization list. Otherwise, there will be an error

In a similar way to how the compiler calls the constructor of the base class when the
derived class is constructed, the compiler takes care of always calling the destructor
of the base class after the destructor of the derived class has run */

#include <string>

class A
{
    public:
        A(const std::string& name);
};

class B : public A
{
    public:
        B(int number) : A("A's name"), d_number(number) { }

    private:
        int d_number;
};

/* When B's constructor is called, the A needs to be initialized. Since A doesn't have
a default constructor, the compiler cannot initialize it for us: we have to call A's
constructor explicitly. The copy constructor and the assignment operator generated by
the compiler take care of calling the constructor and operator of the base class. When,
instead, we write our implementation of the copy constructor and the assignment
operators, we need to take care of calling the copy constructor and assignment operator

Also a general rule is to use the Liskov Substitution Principle: if the A class
inherits from B, we could replace the A class anywhere the B class is used, and the
code would still behave correctly */