#include <iostream>

class class_name
{
    class_name(class_name&& other) {
        std::cout << "move constructor called!" << std::endl;
    }

    class_name& operator = (class_name&& other) {
        std::cout << "move-assignment operator called!" << std::endl;
        return *this;
    }
};

/* class WrongMove
{
    public:
        WrongMove() : _resource(acquire_resource()) { }

        WrongMove(WrongMove&& other) {
            _resource = other._resource;
            other._resource = resetted_resource();
            // Wrong: we never reset other._resource
        }

        ~WrongMove() {
            if (not is_reset_resource(_resource)) {
                release_resource(_resource);
            }
        }

    private:
        Resource _resource;
}; */

/* The move constructor and move assignment operator
can be implicitly generated by the compiler if no user-defined
ones are provided and there are no user-declared destructors,
copy constructors, or copy or move assignment operators: */
struct MovableClass
{
    MovableClass() { }

    MovableClass(MovableClass&& other) {
        std::cout << "Move construct" << std::endl;
    }

    MovableClass& operator = (MovableClass&& other) {
        std::cout << "Move assign" << std::endl;
        return *this;
    }
};

// it's possible to prevent implicit copy or move of our class if we desire to
class Rectangle
{
    int length, width;

    // prevent implicit move constructor
    Rectangle(Rectangle&& other) = delete;

    // prevent implicit move operator
    Rectangle& operator = (Rectangle&& other) = delete;  
};

int main()
{
    // Acquires the resource
    /* WrongMove first;
    { */
        /* Call the move constructor: we copy the resource to second, but we are
        not resetting it in first */
        /* WrongMove second(std::move(first));
    } */
    /* Second is destroyed: second._resource is released here. Since we copied
        the resource, now first._resource has been released as well. */

    // Move construct
    MovableClass first;
    MovableClass second(std::move(first));
    // or MovableClass second = std::move(first);

    // Move assignment
    MovableClass third;
    second = std::move(third);

    return 0;
}
// First is destroyed: the same resource is released again! Error!